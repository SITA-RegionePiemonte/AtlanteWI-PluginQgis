# -*- coding: utf-8 -*-"""/*******************************************Copyright: Regione Piemonte 2012-2019SPDX-Licene-Identifier: GPL-2.0-or-later*******************************************//***************************************************************************CSIAtlanteWIAccesso organizzato a dati e geoserviziA QGIS plugin, designed for an organization where the Administrators of theGeographic Information System want to guide end usersin organized access to the data and geo-services of their interest.Date : 2019-11-16copyright : (C) 2012-2019 by Regione Piemonteauthor : Enzo Ciarmoli(CSI Piemonte), Luca Guida(Genegis), Matteo Tranquillini(Trilogis), Stefano Giorgi (CSI Piemonte) email : supporto.gis@csi.itNote:The content of this file is based on- DB Manager by Giuseppe Sucameli <brush.tyler@gmail.com> (GPLv2 license)- PG_Manager by Martin Dobias <wonder.sk@gmail.com> (GPLv2 license)***************************************************************************//**************************************************************************** ** This program is free software; you can redistribute it and/or modify ** it under the terms of the GNU General Public License as published by ** the Free Software Foundation; either version 2 of the License, or ** (at your option) any later version. ** ****************************************************************************/"""import osimport codecsimport datetimefrom PyQt5.QtCore import Qt, QSettingsfrom PyQt5.QtGui import QCursor, QPixmapfrom PyQt5.QtWidgets import QApplicationfrom qgis.PyQt import QtCorefrom qgis.core import QgsApplicationfrom .. import configurationdef get_compact_xml_string_from_qgs_file(qgs_xml):    """        Removes the DOCTYPE (e.g. <!DOCTYPE qgis PUBLIC 'http://mrcc.com/qgis.dtd' 'SYSTEM'>) line, if present.        Executes the line strip for each line        :param qgs_xml: The XML representing the QGS project        :type qgs_xml: str        :return: The resulting XML        :rtype: str    """    with codecs.open(qgs_xml, 'r', "utf-8") as f:        lines = f.readlines()        # In case there is the DOCTYPE definition as the first line, remove it        if lines[0].find("DOCTYPE") > 0:            del lines[0]        clean_lines = [l.strip() for l in lines if l.strip()]    cleaned_xml = ''.join(clean_lines)    return cleaned_xmldef get_plugin_settings():    """        Retrieve the plugin settings from the plugin deployment folder        (e.g. Roaming\QGIS\QGIS3\profiles\default\python\plugins\CSIAtlanteWI)        For future reference of using a local 'settings.ini' file instead of the configuration.py        :return: The :QSettings: object or None if no plugin settings could be found in the plugin deployment directory    """    # Getting the logger    qgs_logger = QgsApplication.messageLog()    plugin_path = os.path.dirname(os.path.realpath(__file__))    plugin_settings_path = os.path.join(plugin_path, "settings.ini")    # Loading the given settings file    qgs_settings = get_qgs_settings_from_file(plugin_settings_path)    return qgs_settingsdef get_qgs_settings_from_file(settings_file_path):    """        Retrieve the QSettings object from the given file        :param settings_file_path: The 'ini' settings file path        :type settings_file_path: str        :return: The QSettings        :rtype: QSettings    """    assert isinstance(settings_file_path, str), "Wrong type for 'settings_file_path', expected str"    assert os.path.exists(settings_file_path), "The given path doesn't exist: " + settings_file_path    assert os.path.isfile(settings_file_path), "The given path is not a file: " + settings_file_path    # Loading the given settings file    qgs_settings = QSettings(settings_file_path, QSettings.IniFormat)    return qgs_settingsdef get_qgs_settings_value_or_default(value_key, default=None, value_type=str, settings_file_path=None):    """        Retrieve from the QSettings the value for the key 'value_key' or returns the value in 'default' if there is no        value (or it is an empty string, since QSettings values are string-based).        In case there is a value for 'value_key' it attempts to cast to the 'value_type', but if it fails, it will        return 'default'        :param value_key: The value key for the QSettings        :type value_key: str        :param default: The value to return in case there is no value for 'value_key'        :type default: type        :param value_type: The expected retunred value type        :type value_type: type        :param settings_file_path: In case a different from the QGIS one is being used        :type settings_file_path: str        :return: The value for the 'value_key' or 'default'        :rtype: type    """    assert isinstance(value_type, type), "The variable 'value_type' doesn't represent a 'type'"    # Getting the logger    qgs_logger = QgsApplication.messageLog()    if settings_file_path is None or len(settings_file_path) == 0:        qgs_settings = QtCore.QSettings()    else:        # Loading the given settings file        qgs_settings = get_qgs_settings_from_file(settings_file_path)    if value_key is None or len(value_key) == 0:        return default    # QSettings work as string based file, so the value could be '' in case the key exists, but not set    value = qgs_settings.value(value_key, None)    if not value:        return default    try:        return value_type(value)    except Exception as e:        qgs_logger.logMessage("Unable to cast to " + str(value_type), tag=configuration.LOGGER_TAG)        return defaultdef restore_qgs_cursor():    """       Resetting the cursor on QGis    """    QApplication.instance().restoreOverrideCursor()def restore_qgs_cursors_stack():    """        Resetting the cursors stack    """    while QApplication.instance().overrideCursor() > 0:        QApplication.instance().restoreOverrideCursor()def set_qgs_arrow_cursor():    """        Setting the 'arrow' cursor on QGis    """    cursor = QCursor(Qt.ArrowCursor)    QApplication.instance().setOverrideCursor(cursor)def set_qgs_hourglass_cursor():    """        Setting the 'hourglass' cursor on QGis    """    cursor = QCursor(Qt.WaitCursor)    QApplication.instance().setOverrideCursor(cursor)def set_qgs_custom_cursor():    """       Setting the 'custom' cursor on QGis    """    cursor = QCursor(QPixmap(["16 16 3 1",                              "      c None",                              ".     c #FF0000",                              "+     c #faed55",                              "                ",                              "       +.+      ",                              "      ++.++     ",                              "     +.....+    ",                              "    +.  .  .+   ",                              "   +.   .   .+  ",                              "  +.    .    .+ ",                              " ++.    .    .++",                              " ... ...+... ...",                              " ++.    .    .++",                              "  +.    .    .+ ",                              "   +.   .   .+  ",                              "   ++.  .  .+   ",                              "    ++.....+    ",                              "      ++.++     ",                              "       +.+      "]))    QApplication.instance().setOverrideCursor(cursor)def set_qgs_settings_value(value_key, value, settings_file_path=None):    """        Store in the QSettings the value for the key 'value_key'. The value will be casted to str        It will overwrite any existing value.        :param value_key: The value key for the QSettings        :type value_key: str        :param value: The value to store        :type value: type        :param settings_file_path: In case a different from the QGIS one is being used        :type settings_file_path: str    """    assert isinstance(value_key, str), "Wrong 'value_key' given, expected str"    if settings_file_path is None or len(settings_file_path) == 0:        qgs_settings = QtCore.QSettings()    else:        # Loading the given settings file        qgs_settings = get_qgs_settings_from_file(settings_file_path)    # Setting the value    qgs_settings.setValue(value_key, value)def write_log_message(message, tag, level):    """        Write the message in the configured log file        :param message: The message to log        :type message: str        :param tag: The tag to use        :type tag: str        :param level: The level (expected to be Qgis.Info, Qgis.Warning, Qgis.Success, Qgis.Critical)        :type level: int    """    # Getting the log file path from configuration    log_file_path = get_qgs_settings_value_or_default("CSIAtlanteWI/logfile",default=configuration.CSI_LOG_FILE_PATH,                                                      value_type=str)    # Checking the existence of the directory containing the file, in case create it    directory = os.path.dirname(log_file_path)    if not os.path.exists(directory):        os.makedirs(directory)    # Log the message to file    with open(log_file_path, 'a') as log_file:        now = datetime.datetime.now()        log_time = now.strftime("%Y-%m-%dT%H:%M:%S")        log_file.write('[{logtime}] [{tag}] [{level}] : {message} \n'                       .format(logtime=log_time, tag=tag, level=level, message=message.encode("UTF-8")))